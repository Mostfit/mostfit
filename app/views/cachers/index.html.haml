= js_include_tag 'jquery.tablesorter.min'
:javascript
  $('.chosen').chosen();
  $.tablesorter.addParser({ 
  id: 'mostfit_currency', 
  is: function(s) { 
  return false; 
  }, 
  format: function(s) { 
  return parseFloat(s.replace(/ /g, ''))
  }, 
  type: 'numeric' 
  }); 
     
  $(document).ready(function(){
    $($('table')[0]).tablesorter({headers: { 
    0: { sorter: 'date' },
    3: { sorter: 'mostfit_currency' },
    4: { sorter: 'mostfit_currency' },
    5: { sorter: 'mostfit_currency' },
    6: { sorter: 'mostfit_currency' },
    7: { sorter: 'mostfit_currency' }
    }} )});

- keys = [:date, :branch_id, :center_id, :scheduled_outstanding_total, :actual_outstanding_total, :scheduled_outstanding_principal,:actual_outstanding_principal, :principal_due, :principal_paid, :interest_due, :interest_paid, :fees_due_today, :fees_paid_today, :total_fees_due, :total_fees_paid]
- total_keys = [:scheduled_outstanding_total, :actual_outstanding_total, :scheduled_outstanding_principal,:actual_outstanding_principal, :principal_due, :principal_paid, :interest_due, :interest_paid, :fees_due_today, :fees_paid_today, :total_fees_due, :total_fees_paid]
- query_params = request.send(:query_params)
%h3
  = link_to "#{Cacher.stale.count} stale caches", resource(:cachers, :stale => true)
= form(:method => :get, :action => resource(:cachers)) do
  = date_select_old_html(:name => 'date', :id => 'date', :min_date => Cacher.aggregate(:date.min), :max_date => Cacher.aggregate(:date.max), :date => @date)
  = select :name => 'branch_id', :id => "branch_selector", :collection => Branch.all, :text_method => :name, :value_method => :id, :selected => params[:branch_id].to_s, :prompt => 'Select a branch', :class => 'chosen'
  = select :name => 'center_id', :id => 'center_selector', :collection => Center.all(:branch_id => params[:branch_id]), :text_method => :name, :value_method => :id, :selected => params[:center_id].to_s, :prompt => 'Select a center', :class => 'chosen'
  = submit 'apply filter'

%table.diags{:style => "width: 1400px;"}
  %thead
    %tr
      - keys.each do |at|
        %th
          = at.to_s.gsub("_","<br>")
  - if params  and params[:center_id] and params[:date]
    - total = {}
    - cen = Center.get(params[:center_id])
    - histories = LoanHistory.latest({:center_id => cen.id}, @date)
    - histories.each do |h|
      %tr
        - keys.each do |at|
          - val = h.send(at)
          %td
            = val.is_a?(Numeric) ? val.to_currency(:mostfit_default) : val
            - total[at] ||= 0
            - total[at] += h.send(at) if h.send(at).is_a? Numeric
        %td{:style => "background: #aaee00"}
          = link_to h.composite_key, "/loans/#{h.composite_key.floor}"
    %tr.total
      - keys.each do |at|
        %td
          = total[at].to_i.to_currency(:mostfit_default)
  - total_row = {}
  - @cachers.sort_by{|c| [c.branch_id,c.center_id]}.each do |c|
    %tr{:class => cycle('odd','even')}
      - keys.each do |at|
        - val = c.send(at)
        %td{:style => "text-align: right"}
          - if at == :date
            = link_to val, resource(:cachers, request.send(:query_params).merge(:date => val))
          - elsif at == :branch_id
            - br = Branch.get(val)
            = link_to((br ? br.name : "-"), resource(:cachers, request.send(:query_params).merge(:branch_id => br.id)))
          - elsif at == :center_id
            - cen = Center.get(val)
            = link_to((cen ? cen.name[0..10] : "-"), resource(:cachers, request.send(:query_params).merge(:center_id => cen, :date => c.date)))
          - else
            = val == 0 ? "-" : val.to_currency(:mostfit_default)
          - if total_keys.include?(at)
            - total_row[at] ||= 0
            - total_row[at] += val unless c.center_id == 0
  %tfoot
    %tr.total
      - keys.each do |k|
        %th{:style => "text-align: right"}
          - if total_keys.include?(k)
            = total_row[k].to_currency
          - else
            &nbsp;
      

